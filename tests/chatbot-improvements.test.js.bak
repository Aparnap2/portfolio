/**
 * Comprehensive test suite for chatbot UI/UX improvements
 * Tests responsiveness, performance, accessibility, and user experience
 */

import { test, expect } from '@playwright/test';

// Mock framer-motion to avoid animation issues in tests
jest.mock('framer-motion', () => ({
  motion: {
    div: ({ children, ...props }) => <div {...props}>{children}</div>,
    button: ({ children, ...props }) => <button {...props}>{children}</button>,
    span: ({ children, ...props }) => <span {...props}>{children}</span>,
  },
  AnimatePresence: ({ children }) => children,
}));

// Mock hooks
jest.mock('../src/hooks/useResponsive', () => ({
  useResponsive: () => ({
    isMobile: false,
    isTablet: false,
    isDesktop: true,
    width: 1024,
    height: 768,
    isTouch: false,
    prefersReducedMotion: false,
    getResponsiveValue: (values) => values.md || values.default,
    breakpoints: { xs: 0, sm: 640, md: 768, lg: 1024, xl: 1280 }
  })
}));

jest.mock('../src/hooks/useChatbotPerformance', () => ({
  useChatbotPerformance: () => ({
    trackEngagement: jest.fn(),
    trackError: jest.fn(),
    getMetrics: jest.fn(() => ({
      messageCount: 0,
      averageResponseTime: 0,
      errorCount: 0
    }))
  })
}));

jest.mock('../src/hooks/useDebounce', () => ({
  useDebounce: (value) => value
}));

// Import components after mocking
import Chatbot from '../src/app/component/chatbot/chatbot';
import ChatbotComponent from '../src/app/component/chatbot/ChatbotComponent';
import ChatMessage from '../src/app/component/chatbot/ChatMessage';
import LazyChatbot from '../src/app/component/chatbot/LazyChatbot';

describe('Chatbot UI/UX Improvements', () => {
  
  describe('Responsiveness Tests', () => {
    test('should render floating action button with correct size', () => {
      render(<Chatbot />);
      const button = screen.getByRole('button', { name: /open ai assistant/i });
      expect(button).toBeInTheDocument();
      expect(button).toHaveClass('w-16', 'h-16'); // Desktop size
    });

    test('should handle mobile viewport correctly', () => {
      // Mock mobile viewport
      const mockUseResponsive = jest.requireMock('../src/hooks/useResponsive').useResponsive;
      mockUseResponsive.mockReturnValue({
        isMobile: true,
        isTablet: false,
        isDesktop: false,
        width: 375,
        height: 667,
        isTouch: true,
        prefersReducedMotion: false,
        getResponsiveValue: (values) => values.xs || values.default,
      });

      render(<Chatbot />);
      const button = screen.getByRole('button', { name: /open ai assistant/i });
      expect(button).toHaveClass('w-14', 'h-14'); // Mobile size
    });

    test('should adapt container dimensions based on screen size', () => {
      const mockProps = {
        onClose: jest.fn(),
        onMinimize: jest.fn(),
        isMobile: true,
        windowSize: { width: 375, height: 667 }
      };

      render(<ChatbotComponent {...mockProps} />);
      
      // Mobile should use full viewport
      const container = screen.getByRole('dialog', { hidden: true }) || 
                       document.querySelector('[style*="width"]');
      
      // Check if mobile-specific styles are applied
      expect(container).toBeTruthy();
    });
  });

  describe('Performance Optimizations', () => {
    test('should use lazy loading for chatbot component', async () => {
      render(<LazyChatbot />);
      
      // Should show loading fallback initially
      const loadingElement = screen.getByRole('button');
      expect(loadingElement).toBeInTheDocument();
      
      // Wait for lazy component to load
      await waitFor(() => {
        expect(screen.getByRole('button')).toBeInTheDocument();
      });
    });

    test('should debounce input changes', async () => {
      const mockProps = {
        onClose: jest.fn(),
        isMobile: false,
        windowSize: { width: 1024, height: 768 }
      };

      render(<ChatbotComponent {...mockProps} />);
      
      const textarea = screen.getByPlaceholderText(/tell me about your business/i);
      
      // Rapid typing should be debounced
      fireEvent.change(textarea, { target: { value: 'H' } });
      fireEvent.change(textarea, { target: { value: 'He' } });
      fireEvent.change(textarea, { target: { value: 'Hello' } });
      
      expect(textarea.value).toBe('Hello');
    });

    test('should track performance metrics', () => {
      const mockPerformanceHooks = {
        trackEngagement: jest.fn(),
        trackError: jest.fn(),
        getMetrics: jest.fn()
      };

      const mockProps = {
        onClose: jest.fn(),
        performanceHooks: mockPerformanceHooks,
        isMobile: false
      };

      render(<ChatbotComponent {...mockProps} />);
      
      // Should track engagement on render
      expect(mockPerformanceHooks.trackEngagement).toHaveBeenCalled();
    });
  });

  describe('Accessibility Features', () => {
    test('should have proper ARIA labels', () => {
      render(<Chatbot />);
      
      const button = screen.getByRole('button', { name: /open ai assistant/i });
      expect(button).toHaveAttribute('aria-label');
    });

    test('should support keyboard navigation', () => {
      const mockProps = {
        onClose: jest.fn(),
        isMobile: false
      };

      render(<ChatbotComponent {...mockProps} />);
      
      const textarea = screen.getByRole('textbox');
      
      // Should handle Enter key for submission
      fireEvent.keyDown(textarea, { key: 'Enter', code: 'Enter' });
      
      // Should handle Shift+Enter for new line
      fireEvent.keyDown(textarea, { 
        key: 'Enter', 
        code: 'Enter', 
        shiftKey: true 
      });
      
      expect(textarea).toBeInTheDocument();
    });

    test('should respect reduced motion preferences', () => {
      const mockUseResponsive = jest.requireMock('../src/hooks/useResponsive').useResponsive;
      mockUseResponsive.mockReturnValue({
        isMobile: false,
        prefersReducedMotion: true,
        getResponsiveValue: (values) => values.default
      });

      render(<Chatbot />);
      
      // Animations should be disabled or reduced
      const button = screen.getByRole('button');
      expect(button).toBeInTheDocument();
    });

    test('should have proper focus management', () => {
      const mockProps = {
        onClose: jest.fn(),
        isMobile: false
      };

      render(<ChatbotComponent {...mockProps} />);
      
      const textarea = screen.getByRole('textbox');
      const closeButton = screen.getByRole('button', { name: /close chat/i });
      
      // Elements should be focusable
      expect(textarea).toHaveAttribute('tabIndex', '0');
      expect(closeButton).not.toHaveAttribute('tabIndex', '-1');
    });
  });

  describe('User Experience Features', () => {
    test('should show typing indicator when user is typing', async () => {
      const mockProps = {
        onClose: jest.fn(),
        isMobile: false
      };

      render(<ChatbotComponent {...mockProps} />);
      
      const textarea = screen.getByRole('textbox');
      
      // Start typing
      fireEvent.change(textarea, { target: { value: 'Hello' } });
      
      // Should show typing indicator (implementation dependent)
      await waitFor(() => {
        // Check for typing indicator elements
        const typingElements = document.querySelectorAll('[class*="typing"]');
        expect(typingElements.length).toBeGreaterThanOrEqual(0);
      });
    });

    test('should handle error states gracefully', () => {
      const mockProps = {
        onClose: jest.fn(),
        isMobile: false,
        performanceHooks: {
          trackError: jest.fn(),
          trackEngagement: jest.fn(),
          getMetrics: jest.fn()
        }
      };

      render(<ChatbotComponent {...mockProps} />);
      
      // Should render without crashing even with errors
      expect(screen.getByRole('textbox')).toBeInTheDocument();
    });

    test('should support message retry functionality', () => {
      const mockProps = {
        onClose: jest.fn(),
        isMobile: false,
        performanceHooks: {
          trackError: jest.fn(),
          trackEngagement: jest.fn(),
          getMetrics: jest.fn()
        }
      };

      render(<ChatbotComponent {...mockProps} />);
      
      // Error retry functionality should be available
      // (Implementation would depend on error state management)
      expect(screen.getByRole('textbox')).toBeInTheDocument();
    });

    test('should render messages with proper formatting', () => {
      const mockMessage = {
        role: 'assistant',
        content: 'Hello! How can I help you today?',
        timestamp: new Date().toISOString(),
        confidence: 0.95
      };

      render(<ChatMessage message={mockMessage} isMobile={false} />);
      
      expect(screen.getByText(/hello! how can i help you today/i)).toBeInTheDocument();
      expect(screen.getByText(/95%/)).toBeInTheDocument(); // Confidence indicator
    });

    test('should handle window minimize/maximize functionality', () => {
      const mockOnMinimize = jest.fn();
      const mockProps = {
        onClose: jest.fn(),
        onMinimize: mockOnMinimize,
        isMobile: false,
        isMinimized: false
      };

      render(<ChatbotComponent {...mockProps} />);
      
      // Should have minimize button on desktop
      const minimizeButton = screen.queryByRole('button', { name: /minimize chat/i });
      if (minimizeButton) {
        fireEvent.click(minimizeButton);
        expect(mockOnMinimize).toHaveBeenCalled();
      }
    });
  });

  describe('Touch and Mobile Interactions', () => {
    test('should handle touch interactions properly', () => {
      const mockUseResponsive = jest.requireMock('../src/hooks/useResponsive').useResponsive;
      mockUseResponsive.mockReturnValue({
        isMobile: true,
        isTouch: true,
        prefersReducedMotion: false,
        getResponsiveValue: (values) => values.xs || values.default
      });

      render(<Chatbot />);
      
      const button = screen.getByRole('button');
      
      // Touch interactions should work
      fireEvent.touchStart(button);
      fireEvent.touchEnd(button);
      
      expect(button).toBeInTheDocument();
    });

    test('should prevent body scroll on mobile when open', () => {
      const mockUseResponsive = jest.requireMock('../src/hooks/useResponsive').useResponsive;
      mockUseResponsive.mockReturnValue({
        isMobile: true,
        isTouch: true
      });

      render(<Chatbot />);
      
      const button = screen.getByRole('button');
      fireEvent.click(button);
      
      // Should prevent body scroll (implementation dependent)
      expect(button).toBeInTheDocument();
    });
  });

  describe('Error Boundary and Fallbacks', () => {
    test('should handle component errors gracefully', () => {
      // Mock console.error to avoid noise in tests
      const consoleSpy = jest.spyOn(console, 'error').mockImplementation(() => {});
      
      // Component should not crash the entire app
      render(<LazyChatbot />);
      
      expect(screen.getByRole('button')).toBeInTheDocument();
      
      consoleSpy.mockRestore();
    });

    test('should show loading states appropriately', () => {
      render(<LazyChatbot />);
      
      // Should show some form of loading indicator
      const loadingElement = screen.getByRole('button');
      expect(loadingElement).toBeInTheDocument();
    });
  });

  describe('Performance Monitoring', () => {
    test('should track user engagement metrics', () => {
      const mockTrackEngagement = jest.fn();
      const mockProps = {
        onClose: jest.fn(),
        performanceHooks: {
          trackEngagement: mockTrackEngagement,
          trackError: jest.fn(),
          getMetrics: jest.fn()
        }
      };

      render(<ChatbotComponent {...mockProps} />);
      
      // Should track initial engagement
      expect(mockTrackEngagement).toHaveBeenCalled();
    });

    test('should provide performance metrics', () => {
      const mockGetMetrics = jest.fn(() => ({
        messageCount: 5,
        averageResponseTime: 1200,
        errorCount: 0
      }));

      const mockProps = {
        onClose: jest.fn(),
        performanceHooks: {
          trackEngagement: jest.fn(),
          trackError: jest.fn(),
          getMetrics: mockGetMetrics
        }
      };

      render(<ChatbotComponent {...mockProps} />);
      
      // Metrics should be available
      expect(mockGetMetrics).toBeDefined();
    });
  });
});

// Integration tests
describe('Chatbot Integration Tests', () => {
  test('should handle complete user interaction flow', async () => {
    const mockProps = {
      onClose: jest.fn(),
      isMobile: false,
      performanceHooks: {
        trackEngagement: jest.fn(),
        trackError: jest.fn(),
        getMetrics: jest.fn()
      }
    };

    render(<ChatbotComponent {...mockProps} />);
    
    // User types a message
    const textarea = screen.getByRole('textbox');
    fireEvent.change(textarea, { target: { value: 'Hello, I need help' } });
    
    // User submits the message
    const form = textarea.closest('form');
    if (form) {
      fireEvent.submit(form);
    }
    
    // Should handle the complete flow without errors
    expect(textarea).toBeInTheDocument();
  });

  test('should maintain state consistency across interactions', () => {
    render(<Chatbot />);
    
    const button = screen.getByRole('button');
    
    // Open chatbot
    fireEvent.click(button);
    
    // Should maintain consistent state
    expect(button).toBeInTheDocument();
  });
});